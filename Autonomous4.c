#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Sensor, S3,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     climb,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     sweep,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C2_1,     rightfront,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rightback,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     leftback,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C3_2,     leftfront,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C4_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    kick,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    irservo,              tServoStandard)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-sensormux.h"
#include "hitechnic-irseeker-v2.h"
#include "lego-touch.h"

/////////////SPECIFY TIMES AND VALUES/////////////////////

string welcometext = "I'm Caeser!";
int irout = 127;
int irin = 245;
int kickout = 100;
int kickdeadzone = 4;
int kickrate = 0; //servoChangeRate of kick
int gatepos = 100;

int speed0 = 30;
int speed7 = 25;
int speed6 = 15;
int speedlessthan4 = -10;


int winchpower = 100;
float winchduration = 3; //in seconds
int sonarspeed = 10;
float sonarstop = 3; //sonar value to stop at
int turnspeed = 25;
int stopturnat = 9;			// ir value
float waitafterkick = 3;
int backoutdivisor = 2; // winchmotors need less power when going down
int stopbackoutat = 1;  // ir value
int distancefromwall = 15;
int towallspeed = 25;
int turntorampspeed = 50;
float turntorampduration = 5;
int sidewaysspeed = 40;
float sidewaysduration = 5;
int ontorampspeed =  100;
float ontorampduration = 5;
bool attacking = true;

///////////////////////////////////////////////////////////




#define centeredsmall nxtDisplayCenteredTextLine
#define centeredbig nxtDisplayCenteredBigTextLine
const tMUXSensor irseeker = msensor_S3_1;
const tMUXSensor touchsensor = msensor_S3_2;

int ir;
int right_front, right_back, left_front, left_back;
int winch_motors;
int sweep_motor;
int kickpos = 5;
int irservopos;
bool finishedturn = false;
bool finishedbackout = false;
bool touch;
string sonarstring;

void omnidrive(int y1, int x1, int x2){ //values from 0-100, joystick positions - I decided to do 100 instead of 127//
	right_front = y1-x1-x2;
	right_back = y1+x1-x2;
	left_front = y1+x1+x2;
	left_back = y1-x1+x2;
}

void end(){
omnidrive(0,0,0);
}

void initialize(){
	servoChangeRate[kick] = kickrate;
	kickpos = kickdeadzone;
	servo[irservo] = irout;
	servo[kick] = kickdeadzone;
	centeredsmall(3, "Winch: 0");
	centeredsmall(4, "Kick: %d" , kickpos);
}
//GOTORAMP
task gotoramp(){
	omnidrive(0,0,-turntorampspeed);
	wait1Msec(turntorampduration*1000);
	omnidrive(0,sidewaysspeed,0);
	wait1Msec(sidewaysduration*1000);
	omnidrive(ontorampspeed ,0,0);
	wait1Msec(ontorampduration*1000);
	omnidrive(0,0,0);
	if(attacking == true){
			sweep_motor = 100;
	}
	StopTask(gotoramp);
}
//DRIVETOWALL
task drivetowall(){
	while (true){
		if(SensorValue(sonar) < distancefromwall){
				omnidrive(towallspeed, 0,0);
		}
		if(SensorValue(sonar) <= distancefromwall){
				end();
				StartTask(gotoramp);
				StopTask(drivetowall);
		}
	}
}
//BACKOUT
task backout(){
	kickpos = kickdeadzone;
	irservopos = irin;
	winch_motors = -winchpower/backoutdivisor;
	wait1Msec(winchduration*1000);
	winch_motors = 0;
	omnidrive(0,0,0);
	while(true){
		if(ir > stopbackoutat && ir != 0 && finishedbackout == false){ // ir > (9-stopturnat)
			omnidrive(0,0,turnspeed);
		}
			else if(finishedbackout == true){
			//StartTask(Go Onto Ramp)
				end();
				StopTask(backout);
			}
		if (ir <= stopbackoutat || ir == 0){ // ir <= (9-stopturnat)
			finishedbackout = true;
		}
	}
}
//SCOOTBACKWARDS
task driveawayfrombeacon(){
	while (true){
		if(SensorValue(sonar) < sonarstop){
				omnidrive(-sonarspeed,0,0);
		}
		if(SensorValue(sonar) >= sonarstop){
				end();
				StartTask(backout);
				StopTask(driveawayfrombeacon);
		}
	}
}
//COMPLETEDUMP
task completedump(){
	omnidrive(0,0,0);
	kickpos = kickout;
	wait1Msec(waitafterkick*1000);
	StartTask(backout);
	StopTask(completedump);
}
//SCOOTFORWARDS
task drivetowardsbeacon(){
	while (true){
		if(SensorValue(sonar) > sonarstop){
				omnidrive(sonarspeed,0,0);
		}
		if(SensorValue(sonar) <= sonarstop){
				end();
				StartTask(completedump);
				StopTask(drivetowardsbeacon);
		}
	}
}
//ALIGN
task alignrobot(){
	omnidrive(0,0,0);
	winch_motors = winchpower;
	wait1Msec((winchduration*1000));
	winch_motors = 0;
	while(true){
		if(ir < stopturnat && ir != 0 && finishedturn == false){
				omnidrive(0,0,-turnspeed);
		}
		else if(finishedturn == true){
			StartTask(drivetowardsbeacon);
			StopTask(alignrobot);
		}
		if (ir >= stopturnat || ir == 0){
			finishedturn = true;
		}
	}
}
//DRIVEFORWARD
task driveforward(){
	while(true){
		if(ir == 0){
		omnidrive(speed0 ,0,0);
		}
		if(ir >= 7){
		omnidrive(speed7 , 0,0);
		}
		if(ir == 6){
		omnidrive(speed6 , 0,0);
		}
		if(ir == 5){
		StartTask(alignrobot);
		StopTask(driveforward);
		}
		if(ir <= 4){
		omnidrive(speedlessthan4,0,0); //back up slowly
		}
	}
}

task main()
{
//waitForStart();
initialize();
StartTask(driveforward);
while(true){
touch = TSreadState(touchsensor);
sonarstring = SensorValue(sonar);
ir = HTIRS2readACDir(irseeker);
motor[rightfront] = right_front;
motor[rightback] = right_back;
motor[leftfront] = left_front;
motor[leftback] = left_back;
motor[lift] = winch_motors;
motor[climb] = winch_motors;
motor[sweep] = sweep_motor;
servo[kick] = kickpos;
servo[gate] = gatepos;
servo[irservo] = irservopos;
centeredsmall(0, welcometext);
centeredsmall(1, "LF: %d LB: %d" , left_front, left_back);
centeredsmall(2, "RF: %d RB: %d" , right_front, right_back);
centeredsmall(3, "Winch: %d" , winch_motors);
centeredsmall(4, "Kick: %d" , kickpos);
centeredsmall(5, "Gate: %d" , gatepos);
centeredbig(6, "IR: %d, S: %s", ir, sonarstring);
}
}
