#pragma config(Hubs,  S2, HTServo,  none,     none,     none)
#pragma config(Hubs,  S3, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Sensor, S1,     HTSMUX,         sensorI2CCustom)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S3_C1_1,     climb,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S3_C1_2,     sweep,         tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S3_C2_1,     rightfront,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C2_2,     rightback,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C3_1,     leftback,      tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S3_C3_2,     leftfront,     tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S3_C4_1,     lift,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S3_C4_2,     flag,          tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S2_C1_1,    kick,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C1_2,    gate,                 tServoStandard)
#pragma config(Servo,  srvo_S2_C1_3,    servo3,              	tServoNone)
#pragma config(Servo,  srvo_S2_C1_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S2_C1_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/////////////////////////////////////////////////////////
//Omnidrive for driver and second controller for codriver.
//Exponential control with sprint button for full speed
//Left motors must be reversed
/////////////////////////////////////////////////////////

//INCLUDE
#include "JoystickDriver.c"  //I edited out the write to screen section
#include "hitechnic-sensormux.h" //Sensor multiplexer
#include "lego-touch.h" //Third party touch sensor drivers for lift

//DEFINE
////The following define statements simplify code
#define joy1x1 joystick.joy1_x1////////
#define joy1x2 joystick.joy1_x2////////
#define joy1y1 joystick.joy1_y1////////
#define joy1y2 joystick.joy1_y2////////
#define joy2x1 joystick.joy2_x1////////
#define joy2x2 joystick.joy2_x2////////
#define joy2y1 joystick.joy2_y1////////
#define joy2y2 joystick.joy2_y2////////
///////////////////////////////////////

//The touch sensor is in port two of the multiplexer. IR isn't used during Teleop.
const tMUXSensor touch = msensor_S1_2;

//Joystick dead zone for faulty joysticks
int deadzone = 20;

//Gate and kick servo positions.
//Angle out of 254- i.e. 127 = 90 degrees, 191 = 135 degrees
int gate_up = 100;
int gate_down = 236;
int little_kick = 48;
int big_kick = 98;
int servo_deadzone = 8;

//Flag motor
int flagupspeed = 100;
int flagdownspeed = 1;

//Exponential divisors and exponents
int expo_sweep = 3;
int base_sweep = 10000;
int expo_lift = 3;
int base_lift = 10000;
int sweep_divisor = 6;

//Variables for various motors to equal. Not required, but simplifies code
float rfspeed;
float rbspeed;
float lfspeed;
float lbspeed;
float sweep_motor;
float winch_motors;  //Both "climb" and "lift" motors are physically connected
										 //so they must receive same commands

//Sprint Button
int sprintdivisorvalue = 3; //Caeser goes x times slower when the sprint button isn't pressed.
int sprintdivisor; //Changed in code.

//Motor encoder variables
int turnsweeperspeed = 10;
int encoderdeadzone = 23; //Where to stop turning the sweeper (out of 1440)
int encoderint;
int modencoder;
bool turnsweeperrunning = false;

////FUNCTIONS////////////////////////////////////////////////
void omnidrive() //OMNI-All directional drive with sprint
								 //button and reversed left motors
{
	rfspeed = (joy1y1-joy1x1-joy1x2)/sprintdivisor;
	rbspeed = (joy1y1+joy1x1-joy1x2)/sprintdivisor;
	lfspeed = (joy1y1+joy1x1+joy1x2)/sprintdivisor;
	lbspeed = (joy1y1-joy1x1+joy1x2)/sprintdivisor;
}

void initializeRobot() //Recommended for competitions
{
  servo[kick] = 30;
  servo[gate] = 100;
  servoChangeRate[kick] = 0;  //Sets kick servo to max speed
  nMotorEncoder[sweep] = 0;
}

////MAIN/////////////////////////////////////////////////

task main()
{
  initializeRobot();
  waitForStart();

  while (true)
  {
	 getJoystickSettings(joystick);

////JOYSTICK DEADZONES///////////////////////////////////
//With omnidrive, deadzones can't be used in the
//conditional statements, so must be set manually

  	if(abs(joy1y1) < deadzone){
  		 joy1y1 = 0;
  	}
 		else {
 			joy1y1 = joy1y1;
 		}
 		if(abs(joy1x1) < deadzone){
  		 joy1x1 = 0;
  	}
 		else {
 			joy1x1 = joy1x1;
 		}
 		if(abs(joy1x2) < deadzone){
  		 joy1x2 = 0;
  	}
 		else {
 			joy1x2 = joy1x2;
 		}

////SWEEPER///////////////////////////////////////////////
//Y2 on controller 2
//For collecting blocks

    if(abs(joy2y2) > deadzone && (servo[gate] == gate_up)){

    	sweep_motor = ((pow(((abs(joy2y2)*100)/127) , expo_sweep)) / base_sweep);

    	if(joy2y2 < 0){
   			sweep_motor = -sweep_motor/sweep_divisor;
   		}
    }
    else if(turnsweeperrunning == true){
    	sweep_motor = -turnsweeperspeed;
    }
		else {
    	sweep_motor = 0;
    }

////LIFT//////////////////////////////////////////////////
//Y1 on controller 2
//For raising blocks to baskets and hanging above the ramp

    if((joy2y1) > deadzone){
    	winch_motors = ((pow(((abs(joy2y1)*100)/127) , expo_lift)) / base_lift);
    }
    else {
    	if (((joy2y1) < deadzone) && !TSreadState(touch)){
	    	winch_motors = -((pow(((abs(joy2y1)*100)/127) , expo_lift)) / base_lift);
	    }
    	else {
	    	winch_motors = 0;
	    }
	  }

////KICK//////////////////////////////////////////////////
//Buttons 6 & 8 on Controller 2
//For putting blocks in the pendulum baskets

    if(joy2Btn(8) == 1 && servo[gate] == gate_up){
    	servo[kick] = big_kick;
    }
    else if (joy2Btn(6) == 1 && servo[gate] == gate_up){
    	servo[kick] = little_kick;
    }
    else {
    	servo[kick] = servo_deadzone;
    }

////FLAG RAISER///////////////////////////////////////////
//Buttons 5 & 7 on Controller 2

    if(joy2Btn(7) == 1){
    	motor[flag] = flagupspeed; //For raising the flag
    }
    else if(joy2Btn(5) == 1){
    	motor[flag] = -flagdownspeed;  //For lining up and releasing the flag turner
    }
    else {
    	motor[flag] = 0;
    }

////GATE///////////////////////////////////////////////////
//Buttons 1 & 3 on controller 2
//For keeping blocks in the dustpan while driving

    if(joy2Btn(3) == 1){
    	servo[gate] = gate_up;
    }
    if(joy2Btn(1) == 1){
    	servo[gate] = gate_down;
    }

////MOTOR ENCODER//////////////////////////////////////////
//Buttons 2 & 4 on controller 2
//For turning the sweeper so the surgical tubing is upright

    encoderint = (nMotorEncoder[sweep])*360/1440;
		modencoder = encoderint%360;

    if(joy2Btn(4) == 1){ 			//Resets encoder
   		nMotorEncoder[sweep]=0;
    }
    if (joy2Btn(2) == 1){			//Turns sweeper to upright position
    	turnsweeperrunning = true;
		}
		if(turnsweeperrunning == true){
			if(abs(modencoder) < encoderdeadzone){
				turnsweeperrunning = false;
			}
		}
		nxtDisplayCenteredTextLine(1, "%d Cycles", encoderint/360);
		nxtDisplayCenteredBigTextLine(2, "%d", encoderint);
		nxtDisplayCenteredBigTextLine(5, "%d", modencoder);

////DRIVE & SPRINT BUTTON////////////////////////////////////////////////////////
//Button 8, x1, and y1 on Controller 1

 		if(joy1Btn(8) == 1){
			sprintdivisor = (127/100);
 		}
 		else {
			sprintdivisor = ((127*sprintdivisorvalue)/100);
		}

		omnidrive();

////OTHER VARIABLES//////////////////////////////////////////////////////////////

    motor[sweep] = sweep_motor;
    motor[lift] = winch_motors;
    motor[climb] = winch_motors;
		motor[rightfront] = rfspeed;
		motor[rightback] = rbspeed;
		motor[leftback] = lbspeed;
		motor[leftfront] = lfspeed;

/////////////////////////////////////////////////////////////////////////////////
  }
}
